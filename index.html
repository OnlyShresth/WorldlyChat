<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Worldly Chat</title>

<link rel="icon" type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg viewBox='0 0 48 48' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='24' cy='24' r='20' fill='%23d8f3dc' stroke='%2340916c' stroke-width='3.5'/%3E%3Cellipse cx='24' cy='24' rx='17' ry='20' fill='none' stroke='%2352b788' stroke-width='1.5'/%3E%3Cellipse cx='24' cy='24' rx='20' ry='7' fill='none' stroke='%2352b788' stroke-width='1.5'/%3E%3C/svg%3E">

<style>
:root{
  --c1:#d8f3dc; --c2:#b7e4c7; --c3:#95d5b2; --c4:#74c69d;
  --c5:#52b788; --c6:#40916c; --c7:#2d6a4f; --c8:#1b4332;
  --anim-fast: 140ms;
}

/* --- layout & styles --- */
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
  background:linear-gradient(130deg,var(--c1),var(--c3));
  overflow:hidden; /* only messages area scrolls */
  min-height:100vh;
}

.container{
  position:relative;
  width: min(1100px, calc(100% - 160px));
  min-width:360px;
  height: calc(100vh - 70px);
  margin:35px auto;
  display:flex;
  flex-direction:column;
  background:var(--c1);
  border-radius:24px;
  box-shadow:0 7px 28px rgba(115,178,154,0.12);
  overflow:hidden;
}

.header{
  text-align:center;
  background:var(--c2);
  border-radius:24px 24px 0 0;
  padding:1.1rem .6rem;
  position:relative;
  overflow:visible;
}
.header svg{
  width:2.3em;height:2.3em;margin-bottom:.25em;
  transform-origin:center;
  animation:logoPop var(--anim-fast) cubic-bezier(.2,.9,.3,1) both;
}
.header h1{font-size:1.75rem;color:var(--c8);margin-bottom:.15rem}
.header p{font-size:.95rem;color:var(--c7)}

.messages{
  flex:1;
  overflow-y:auto;
  padding:1rem;
  font-size:1rem;
  background:var(--c1);
  -webkit-overflow-scrolling:touch;
}
.messages::-webkit-scrollbar{width:10px}
.messages::-webkit-scrollbar-thumb{
  background:linear-gradient(#cbeed0,#bfe6c3);
  border-radius:999px;border:2px solid rgba(0,0,0,0.03)
}
.messages::-webkit-scrollbar-track{background:transparent}

.message{
  background:var(--c2);
  border-left:4px solid var(--c5);
  border-radius:10px;
  padding:.75em 1em;
  margin-bottom:1em;
  word-break:break-word;
  box-shadow:0 2px 6px rgba(149,213,178,0.12);
  transform-origin:left center;
  opacity:0;
  transform: translateY(6px) scale(.995);
}
.message.pop { animation: msgPop var(--anim-fast) cubic-bezier(.2,.9,.3,1) both; }
@keyframes msgPop{ from { opacity:0; transform: translateY(6px) scale(.985); } to { opacity:1; transform: translateY(0) scale(1); } }

.message-header{
  display:flex;
  justify-content:space-between;
  font-size:.9rem;
  margin-bottom:.35rem;
}
.sender{font-weight:600;color:var(--c7)}
.timestamp{color:var(--c8);opacity:.65;font-size:.88rem}

.message-image{
  display:block;
  width:100%;
  height:auto;
  max-height:60vh;
  margin-top:.45em;
  border-radius:7px;
  object-fit:contain;
  box-shadow:0 3px 10px rgba(0,0,0,0.03);
}

.download{
  margin-top:.4em;padding:.32em .8em;border:none;border-radius:6px;background:var(--c4);color:var(--c8);cursor:pointer;
  transition:transform 120ms ease;
}
.download:active{ transform:translateY(1px) }

.input-area{
  display:flex;
  gap:.6em;
  padding:.75em 1em 1em;
  background:var(--c2);
  border-radius:0 0 24px 24px;
  align-items:center;
}
input[type="text"]{
  flex:1.6;
  padding:.55em 1em;
  border:2px solid var(--c4);
  border-radius:22px;
  background:var(--c1);
  color:var(--c8);
  min-width:0;
  transition:box-shadow 120ms ease, transform 90ms ease;
}
input[type="text"]:focus{outline:none;border-color:var(--c5);box-shadow:0 4px 18px rgba(82,183,136,0.06)}
input[type="file"]{display:none}

.btn{
  width:36px;height:36px;border-radius:50%;border:none;font-size:1.25em;
  display:flex;align-items:center;justify-content:center;background:var(--c4);color:var(--c7);cursor:pointer;flex:0 0 auto;
  transition:transform 120ms cubic-bezier(.2,.9,.3,1), box-shadow 120ms ease;
}
.btn:hover{background:var(--c5)}
.btn:active{ transform:scale(.92) }
.btn.bang{ animation:btnBang 160ms cubic-bezier(.2,.9,.3,1) both; }
@keyframes btnBang{ 0%{ transform:scale(1); } 50%{ transform:scale(1.14); } 100%{ transform:scale(1); } }

#fileToast{
  position:absolute;
  top:12px;
  right:12px;
  background:linear-gradient(180deg,rgba(255,255,255,0.98),var(--c1));
  border:1px solid rgba(82,183,136,0.12);
  box-shadow:0 6px 20px rgba(43,90,77,0.08);
  padding:.45em .6em;border-radius:10px;
  display:flex;gap:.6em;align-items:center;min-width:180px;max-width:320px;
  z-index:60;
  transform: translateY(-6px) scale(.995);
  opacity:0;
  pointer-events:none;
}
#fileToast.show{ animation: toastIn 180ms cubic-bezier(.2,.9,.3,1) both; pointer-events:auto; }
#fileToast.hide{ animation: toastOut 120ms ease both; pointer-events:none; }
@keyframes toastIn{ from{opacity:0;transform:translateY(-8px) scale(.99)} to{opacity:1;transform:translateY(0) scale(1)} }
@keyframes toastOut{ from{opacity:1;transform:translateY(0) scale(1)} to{opacity:0;transform:translateY(-8px) scale(.99)} }

#fileToast .thumb{width:36px;height:36px;border-radius:6px;object-fit:cover;border:1px solid rgba(0,0,0,0.04)}
#fileToast .info{flex:1;overflow:hidden}
#fileToast .fname{font-weight:600;color:var(--c7);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
#fileToast .fmeta{font-size:.82rem;color:var(--c8);opacity:.7;margin-top:2px}
#fileToast button{background:transparent;border:none;cursor:pointer;color:var(--c8);opacity:.9;padding:.25em .4em;border-radius:6px}
#fileToast button:hover{background:rgba(0,0,0,0.04)}

.message:hover{ box-shadow:0 6px 18px rgba(77,144,108,0.06); transform:translateY(-1px); transition:transform 120ms ease, box-shadow 120ms ease; }

@media (max-width: 920px){ .container{ width: min(900px, calc(100% - 80px)); } }
@media (max-width: 720px){
  .container{ width:92vw; margin:18px auto; height:calc(100vh - 36px); border-radius:12px; }
  .header{ padding:.9rem .6rem }
  #fileToast{ top:8px; right:8px; max-width:220px; }
  input[type="text"]{ flex:1.2 }
}
@keyframes logoPop{ from{opacity:0; transform:translateY(-6px) scale(.98) rotate(-6deg)} to{opacity:1; transform:translateY(0) scale(1) rotate(0)} }
</style>
</head>
<body>

<div class="container" id="app">
  <div class="header">
    <svg viewBox="0 0 32 32" aria-hidden="true"><circle cx="16" cy="16" r="14" fill="#d8f3dc" stroke="#40916c" stroke-width="2.3"/><ellipse cx="16" cy="16" rx="11" ry="14" fill="none" stroke="#74c69d" stroke-width="1.3"/><ellipse cx="16" cy="16" rx="14" ry="5.4" fill="none" stroke="#52b788" stroke-width="1.3"/></svg>
    <h1>Worldly Chat</h1>
    <p>Real-time public chat for everyone</p>
  </div>

  <div id="msgs" class="messages" aria-live="polite"><!-- messages appended here --></div>

  <div class="input-area">
    <input id="msgInput" type="text" placeholder="Type a message…" maxlength="700" autocomplete="off">
    <input id="fileInput" type="file" accept="image/*,application/*">
    <button id="pick" class="btn" title="Attach file">+</button>
    <button id="send" class="btn" title="Send">→</button>
  </div>

  <!-- toast (hidden by default) sits in top-right header area -->
  <div id="fileToast" style="display:none" aria-live="polite" role="status">
    <img id="fileThumb" class="thumb" style="display:none" alt="preview">
    <div class="info">
      <div id="fileName" class="fname"></div>
      <div id="fileMeta" class="fmeta"></div>
    </div>
    <div style="display:flex;flex-direction:column;gap:.2em">
      <button id="keepFile" title="Keep file">Keep</button>
      <button id="removeFile" title="Remove file">Remove</button>
    </div>
  </div>
</div>

<!-- one-time name modal -->
<div id="modal" style="position:fixed;inset:0;background:rgba(0,0,0,.07);display:flex;align-items:center;justify-content:center;z-index:200">
  <div style="background:var(--c1);padding:2rem 1.8rem 1.5rem;border-radius:12px;border:1.6px solid var(--c3);text-align:center">
    <h2 style="color:var(--c6);margin-bottom:.9em">Welcome to Worldly Chat</h2>
    <input id="nameInput" placeholder="Your name" style="padding:.7em 1em;width:85%;border:2px solid var(--c4);border-radius:8px;background:var(--c1);color:var(--c8)">
    <br><button id="join" style="margin-top:1em;padding:.55em 1.4em;border:none;border-radius:8px;background:var(--c4);color:var(--c8)">Join</button>
  </div>
</div>

<script type="module">
/* ---------- Firebase boot & imports ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
import {
  getDatabase, ref, push,
  onChildAdded, query, orderByChild,
  get, limitToLast, startAt
} from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";

/* ---------- config ---------- */
const cfg = {
  apiKey:"AIzaSyA4PCKB1MZhPfIfUOnqdT1yP8q_pRYBhcg",
  authDomain:"worldlychat.firebaseapp.com",
  databaseURL:"https://worldlychat-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId:"worldlychat",
  storageBucket:"worldlychat.appspot.com",
  messagingSenderId:"755741319630",
  appId:"1:755741319630:web:83f35e68dea64d8aae0b9f"
};
const app = initializeApp(cfg);
const db = getDatabase(app);
const msgsDB = ref(db, "messages");

/* ---------- helpers ---------- */
const esc = s => String(s ?? "").replace(/[&<>"']/g, ch=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[ch]));
const safeTs = t => { const n = Number(t); return Number.isFinite(n) ? n : Date.now(); };
const $ = id => document.getElementById(id);

/* ---------- DOM refs & state ---------- */
const list   = $("msgs");
const text   = $("msgInput");
const file   = $("fileInput");
const pick   = $("pick");
const send   = $("send");
const modal  = $("modal");
const nameIn = $("nameInput");
const join   = $("join");

const toast      = $("fileToast");
const fileThumb  = $("fileThumb");
const fileNameEl = $("fileName");
const fileMetaEl = $("fileMeta");
const keepBtn    = $("keepFile");
const removeBtn  = $("removeFile");

let username = "";
let pendingFile = null;
let toastTimer = null;

/* guard to avoid rendering the same message twice */
const messageIds = new Set();

/* ---------- join flow ---------- */
join.onclick = () => {
  const n = nameIn.value.trim();
  if(!n){ nameIn.focus(); return; }
  username = n;
  modal.remove();
  text.focus();
  startFeed();
};
nameIn.addEventListener("keypress", e => { if(e.key === "Enter") join.click(); });

/* ---------- pick / send ---------- */
pick.onclick = () => file.click();
file.onchange = () => {
  pendingFile = file.files[0] || null;
  if(pendingFile) showUploadToast(pendingFile);
};

send.onclick = () => {
  send.classList.remove("bang");
  void send.offsetWidth;
  send.classList.add("bang");
  sendMsg();
};

text.addEventListener("keypress", e => {
  if(e.key === "Enter" && !e.shiftKey){
    e.preventDefault();
    send.classList.remove("bang");
    void send.offsetWidth;
    send.classList.add("bang");
    sendMsg();
  }
});

async function sendMsg(){
  const txt = text.value.trim();
  if(!txt && !pendingFile) return;
  if(!username) { alert("Enter your name first."); return; }

  const data = {
    name: username,
    text: txt || "",
    timestamp: Date.now()
  };

  if(pendingFile){
    const fileCopy = pendingFile;
    pendingFile = null;
    file.value = "";
    hideUploadToast();

    try {
      const dataURL = await readFileAsDataURL(fileCopy);
      data.file = dataURL;
      data.fileName = fileCopy.name;
      data.fileType = fileCopy.type || "application/octet-stream";
    } catch (err) {
      console.error("File read failed:", err);
    }
  }

  try {
    await push(msgsDB, data);
  } catch (err) {
    console.error("Failed to push message:", err);
  }

  text.value = "";
}

function readFileAsDataURL(f){
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = e => reject(e);
    reader.readAsDataURL(f);
  });
}

/* ---------- Upload toast ---------- */
function showUploadToast(fileObj){
  fileNameEl.textContent = fileObj.name;
  fileMetaEl.textContent = humanFileSize(fileObj.size);
  if(fileObj.type && fileObj.type.startsWith("image")){
    const reader = new FileReader();
    reader.onload = () => {
      fileThumb.src = reader.result;
      fileThumb.style.display = "block";
    };
    reader.onerror = () => { fileThumb.style.display = "none"; };
    reader.readAsDataURL(fileObj);
  } else {
    fileThumb.style.display = "none";
  }

  toast.style.display = "flex";
  toast.classList.remove("hide");
  void toast.offsetWidth;
  toast.classList.add("show");

  if(toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(() => hideUploadToast(), 6000);
}

function hideUploadToast(){
  toast.classList.remove("show");
  toast.classList.add("hide");
  setTimeout(()=> {
    toast.style.display = "none";
    toast.classList.remove("hide");
  }, 140);
}

keepBtn.addEventListener("click", () => { hideUploadToast(); text.focus(); });
removeBtn.addEventListener("click", () => { pendingFile = null; file.value = ""; hideUploadToast(); text.focus(); });

/* ---------- Real-time feed with robust fallback ---------- */
async function startFeed(){
  list.innerHTML = "";
  messageIds.clear();

  const INITIAL_LIMIT = 200; // tune this if needed

  try {
    // first try the indexed ordered query (fast when .indexOn is present)
    const initialQ = query(msgsDB, orderByChild('timestamp'), limitToLast(INITIAL_LIMIT));
    const snap = await get(initialQ);

    const rows = [];
    snap.forEach(c => rows.push({...c.val(), id: c.key}));
    rows.sort((a,b) => (Number(a.timestamp) || 0) - (Number(b.timestamp) || 0));

    rows.forEach(m => {
      if(m.id && messageIds.has(m.id)) return;
      safeAppendMessage(m, false); // no per-item animation for initial render
      if(m.id) messageIds.add(m.id);
    });

    list.scrollTop = list.scrollHeight;

    // attach live listener for messages strictly newer than lastTs (so we don't reprocess history)
    const lastTs = rows.length ? (Number(rows[rows.length - 1].timestamp) || Date.now()) : Date.now();
    const liveQ = query(msgsDB, orderByChild('timestamp'), startAt(lastTs + 1));
    onChildAdded(liveQ, snapChild => {
      const data = snapChild.val();
      const id = snapChild.key;
      if(!data) return;
      if(id && messageIds.has(id)) return;
      messageIds.add(id);
      safeAppendMessage({...data, id}, true);
      if(isScrolledToBottom(list)) list.scrollTop = list.scrollHeight;
    });

  } catch (err) {
    console.warn("Indexed query failed — falling back to unordered fetch + safe listener:", err);

    try {
      // fallback #1: do a plain get() of the whole messages node (no ordering). This does not require .indexOn.
      const snapAll = await get(msgsDB);
      const rows = [];
      snapAll.forEach(c => rows.push({...c.val(), id: c.key}));
      // sort client-side by timestamp (safe even without DB index)
      rows.sort((a,b) => (Number(a.timestamp) || 0) - (Number(b.timestamp) || 0));

      rows.forEach(m => {
        if(m.id && messageIds.has(m.id)) return;
        safeAppendMessage(m, false);
        if(m.id) messageIds.add(m.id);
      });

      list.scrollTop = list.scrollHeight;
    } catch (err2) {
      console.error("Fallback unordered get() failed:", err2);
    }

    // Attach a safe live listener for new children. onChildAdded on the root will iterate existing children too,
    // but messageIds prevents duplicates. This listener will ensure new messages show up.
    onChildAdded(msgsDB, snapChild => {
      const data = snapChild.val();
      const id = snapChild.key;
      if(!data) return;
      if(id && messageIds.has(id)) return;
      messageIds.add(id);
      safeAppendMessage({...data, id}, true);
      if(isScrolledToBottom(list)) list.scrollTop = list.scrollHeight;
    });
  }
}

/* Append message safely; animate flag controls micro-animation */
function safeAppendMessage(m, animate = true){
  try {
    if(m.id && messageIds.has(m.id)) return;
    if(m.id) messageIds.add(m.id);

    const wasAtBottom = isScrolledToBottom(list);

    const el = document.createElement("div");
    el.className = "message";
    el.dataset.id = m.id || "";

    const header = document.createElement("div");
    header.className = "message-header";
    const sender = document.createElement("span");
    sender.className = "sender";
    sender.textContent = String(m.name ?? "Anonymous");
    const ts = document.createElement("span");
    ts.className = "timestamp";
    ts.textContent = new Date(safeTs(m.timestamp)).toLocaleString();

    header.appendChild(sender);
    header.appendChild(ts);
    el.appendChild(header);

    if(m.text){
      const textDiv = document.createElement("div");
      textDiv.className = "message-text";
      const parts = String(m.text).split(/\r?\n/);
      parts.forEach((p, idx) => {
        textDiv.appendChild(document.createTextNode(p));
        if(idx < parts.length - 1) textDiv.appendChild(document.createElement("br"));
      });
      el.appendChild(textDiv);
    }

    if(m.file){
      if(m.fileType?.startsWith && m.fileType.startsWith("image")){
        const img = new Image();
        img.className = "message-image";
        img.src = m.file;
        img.alt = m.fileName || "uploaded image";
        el.appendChild(img);
      } else {
        const btn = document.createElement("button");
        btn.className = "download";
        btn.textContent = `Download ${m.fileName || "file"}`;
        btn.addEventListener("click", () => downloadDataURL(m.file, m.fileName || "file", m.fileType || "application/octet-stream"));
        el.appendChild(btn);
      }
    }

    list.appendChild(el);

    if(animate){
      requestAnimationFrame(()=> {
        setTimeout(()=> el.classList.add("pop"), 6);
      });
    } else {
      el.style.opacity = "1";
      el.style.transform = "none";
    }

    if(wasAtBottom) list.scrollTop = list.scrollHeight;
  } catch (err) {
    console.error("Render failed for message", m, err);
  }
}

/* ---------- utilities ---------- */
function isScrolledToBottom(el){ return (el.scrollTop + el.clientHeight + 10) >= el.scrollHeight; }

async function downloadDataURL(dataURL, name){
  try {
    const res = await fetch(dataURL);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Download failed:", err);
  }
}

function humanFileSize(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024, dm = 1;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}
</script>
</body>
</html>
