<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Worldly Chat</title>
<meta name="viewport" content="width=device-width,initial-scale=1">

<!--  Favicon (inline SVG)  -->
<link rel="icon" type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg viewBox='0 0 48 48' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='24' cy='24' r='20' fill='%23d8f3dc' stroke='%2340916c' stroke-width='3.5'/%3E%3Cellipse cx='24' cy='24' rx='17' ry='20' fill='none' stroke='%2352b788' stroke-width='1.5'/%3E%3Cellipse cx='24' cy='24' rx='20' ry='7' fill='none' stroke='%2352b788' stroke-width='1.5'/%3E%3C/svg%3E">

<style>
/* ---------- 1. colour palette ---------- */
:root{
  --c1:#d8f3dc; --c2:#b7e4c7; --c3:#95d5b2; --c4:#74c69d;
  --c5:#52b788; --c6:#40916c; --c7:#2d6a4f; --c8:#1b4332;
}
/* ---------- 2. basic layout ---------- */
*{box-sizing:border-box;margin:0}
body{font-family:system-ui,sans-serif;background:linear-gradient(130deg,var(--c1),var(--c3))}
.container{
  max-width:440px;height:calc(100vh - 70px);margin:35px auto;
  display:flex;flex-direction:column;background:var(--c1);
  border-radius:24px;box-shadow:0 7px 28px var(--c2);
}
.header{text-align:center;background:var(--c2);border-radius:24px 24px 0 0;padding:1.2rem .8rem}
.header svg{width:2.3em;height:2.3em;margin-bottom:.25em}
.header h1{font-size:1.65em;color:var(--c8)}
.header p{font-size:.95em;color:var(--c7)}

.messages{
  flex:1;overflow-y:auto;padding:1rem;font-size:1em;background:var(--c1)
}
.message{
  background:var(--c2);border-left:4px solid var(--c5);border-radius:10px;
  padding:.75em 1em;margin-bottom:1em;word-break:break-word;
  box-shadow:0 2px 6px rgba(149,213,178,0.15)
}
.message-header{display:flex;justify-content:space-between;font-size:.9em;margin-bottom:.35em}
.sender{font-weight:600;color:var(--c7)}
.timestamp{color:var(--c8);opacity:.6}
.message-image{display:block;max-width:98%;max-height:210px;margin-top:.45em;border-radius:7px;object-fit:contain}
.download{margin-top:.4em;padding:.32em .8em;border:none;border-radius:6px;background:var(--c4);color:var(--c8);cursor:pointer}

.input-area{
  display:flex;gap:.6em;padding:.75em 1em 1em;background:var(--c2);border-radius:0 0 24px 24px
}
input[type="text"]{
  flex:1;padding:.55em 1em;border:2px solid var(--c4);border-radius:22px;background:var(--c1);color:var(--c8)
}
input[type="text"]:focus{border-color:var(--c5);outline:none}
input[type="file"]{display:none}
.btn{
  width:36px;height:36px;border-radius:50%;border:none;font-size:1.25em;
  display:flex;align-items:center;justify-content:center;background:var(--c4);color:var(--c7);cursor:pointer
}
.btn:hover{background:var(--c5)}
@media(max-width:520px){.container{margin:0;height:100vh;border-radius:0}}
</style>
</head>
<body>

<div class="container">
  <div class="header">
    <svg viewBox="0 0 32 32"><circle cx="16" cy="16" r="14" fill="#d8f3dc" stroke="#40916c" stroke-width="2.3"/><ellipse cx="16" cy="16" rx="11" ry="14" fill="none" stroke="#74c69d" stroke-width="1.3"/><ellipse cx="16" cy="16" rx="14" ry="5.4" fill="none" stroke="#52b788" stroke-width="1.3"/></svg>
    <h1>Worldly Chat</h1>
    <p>Real-time public chat for everyone</p>
  </div>

  <div id="msgs" class="messages"><!-- messages appear here --></div>

  <div class="input-area">
    <input id="msgInput" type="text" placeholder="Type a message…" maxlength="700" autocomplete="off">
    <input id="fileInput" type="file" accept="image/*,application/*">
    <button id="pick" class="btn">+</button>
    <button id="send" class="btn">→</button>
  </div>
</div>

<!-- one-time name modal -->
<div id="modal" style="
  position:fixed;inset:0;background:rgba(0,0,0,.07);display:flex;align-items:center;justify-content:center">
  <div style="background:var(--c1);padding:2rem 1.8rem 1.5rem;border-radius:12px;border:1.6px solid var(--c3);text-align:center">
    <h2 style="color:var(--c6);margin-bottom:.9em">Welcome to Worldly Chat</h2>
    <input id="nameInput" placeholder="Your name" style="padding:.7em 1em;width:85%;border:2px solid var(--c4);border-radius:8px;background:var(--c1);color:var(--c8)">
    <br><button id="join" style="margin-top:1em;padding:.55em 1.4em;border:none;border-radius:8px;background:var(--c4);color:var(--c8)">Join</button>
  </div>
</div>

<script type="module">
/* ---------- Firebase boot ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
import {
  getDatabase, ref, push,
  onChildAdded, query, orderByChild
} from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";

const cfg = {
  apiKey:"AIzaSyA4PCKB1MZhPfIfUOnqdT1yP8q_pRYBhcg",
  authDomain:"worldlychat.firebaseapp.com",
  databaseURL:"https://worldlychat-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId:"worldlychat",
  storageBucket:"worldlychat.appspot.com",
  messagingSenderId:"755741319630",
  appId:"1:755741319630:web:83f35e68dea64d8aae0b9f"
};
const app = initializeApp(cfg);
const db = getDatabase(app);
const msgsDB = ref(db, "messages");

/* ---------- helpers ---------- */
// safe-escape: always convert to string first
const esc = s => String(s ?? "").replace(/[&<>"']/g, ch=>({
  "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
}[ch]));

// small helper: return numeric timestamp fallback
const safeTs = t => {
  const n = Number(t);
  return Number.isFinite(n) ? n : Date.now();
};

const $ = id => document.getElementById(id);

/* ---------- DOM refs & state ---------- */
const list   = $("msgs");
const text   = $("msgInput");
const file   = $("fileInput");
const pick   = $("pick");
const send   = $("send");
const modal  = $("modal");
const nameIn = $("nameInput");
const join   = $("join");

let username = "";
let pendingFile = null;

/* ---------- join flow ---------- */
join.onclick = () => {
  const n = nameIn.value.trim();
  if(!n){ nameIn.focus(); return; }
  username = n;
  modal.remove();
  text.focus();
  startFeed();
};
nameIn.addEventListener("keypress", e => { if(e.key === "Enter") join.click(); });

/* ---------- pick / send ---------- */
pick.onclick = () => file.click();
file.onchange = () => pendingFile = file.files[0] || null;

send.onclick = sendMsg;
text.addEventListener("keypress", e => {
  if(e.key === "Enter" && !e.shiftKey){
    e.preventDefault();
    sendMsg();
  }
});

async function sendMsg(){
  const txt = text.value.trim();
  if(!txt && !pendingFile) return; // nothing to send
  if(!username) { alert("Enter your name first."); return; }

  // construct base payload
  const data = {
    name: username,
    text: txt || "",           // keep empty string instead of undefined
    timestamp: Date.now()
  };

  // if there's a file, read it as data URL (async)
  if(pendingFile){
    const fileCopy = pendingFile;
    pendingFile = null;
    file.value = ""; // reset input immediately

    try {
      const dataURL = await readFileAsDataURL(fileCopy);
      data.file = dataURL;
      data.fileName = fileCopy.name;
      data.fileType = fileCopy.type || "application/octet-stream";
    } catch (err) {
      console.error("File read failed:", err);
      // proceed without file
    }
  }

  try {
    // push returns a promise; we don't need to await for UI
    await push(msgsDB, data);
  } catch (err) {
    console.error("Failed to push message:", err);
  }

  text.value = "";
}

/* Helper to read a file into a data URL (returns Promise) */
function readFileAsDataURL(f){
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = e => reject(e);
    reader.readAsDataURL(f);
  });
}

/* ---------- Real-time feed ---------- */
/* We attach onChildAdded ordered by timestamp. This streams messages in order
   and appends each new child to the DOM, avoiding re-rendering the whole list. */
function startFeed(){
  // clear existing DOM just in case
  list.innerHTML = "";

  // order by timestamp ensures chronological order
  const q = query(msgsDB, orderByChild('timestamp'));
  onChildAdded(q, snap => {
    const data = snap.val();
    // defensive: if data is null/undefined, skip
    if(!data) return;
    safeAppendMessage({ ...data, id: snap.key });
  });
}

/* Append a single message node to DOM safely */
function safeAppendMessage(m){
  try {
    const wasAtBottom = isScrolledToBottom(list);

    const el = document.createElement("div");
    el.className = "message";
    el.dataset.id = m.id || "";

    // header
    const header = document.createElement("div");
    header.className = "message-header";
    const sender = document.createElement("span");
    sender.className = "sender";
    sender.textContent = esc(m.name); // already escaped into string
    const ts = document.createElement("span");
    ts.className = "timestamp";
    ts.textContent = new Date(safeTs(m.timestamp)).toLocaleString();

    header.appendChild(sender);
    header.appendChild(ts);
    el.appendChild(header);

    // message text (preserve newlines without using innerHTML)
    if(m.text){
      const textDiv = document.createElement("div");
      textDiv.className = "message-text";
      // split on newlines and append text nodes and <br>
      const parts = String(m.text).split(/\r?\n/);
      parts.forEach((p, idx) => {
        textDiv.appendChild(document.createTextNode(p));
        if(idx < parts.length - 1) textDiv.appendChild(document.createElement("br"));
      });
      el.appendChild(textDiv);
    }

    // file handling
    if(m.file){
      if(m.fileType?.startsWith && m.fileType.startsWith("image")){
        const img = new Image();
        img.className = "message-image";
        img.src = m.file;
        img.alt = m.fileName || "uploaded image";
        el.appendChild(img);
      } else {
        const btn = document.createElement("button");
        btn.className = "download";
        btn.textContent = `Download ${m.fileName || "file"}`;
        btn.addEventListener("click", () => downloadDataURL(m.file, m.fileName || "file", m.fileType || "application/octet-stream"));
        el.appendChild(btn);
      }
    }

    list.appendChild(el);

    // auto-scroll behavior: scroll if user was at bottom already
    if(wasAtBottom) list.scrollTop = list.scrollHeight;
  } catch (err) {
    // catch to avoid one bad message breaking feed
    console.error("Render failed for message", m, err);
  }
}

/* ---------- utilities ---------- */
function isScrolledToBottom(el){
  return (el.scrollTop + el.clientHeight + 10) >= el.scrollHeight;
}

/* download base64/dataURL content by creating a temporary blob URL */
async function downloadDataURL(dataURL, name, type){
  try {
    const res = await fetch(dataURL);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Download failed:", err);
  }
}
</script>
</body>
</html>
